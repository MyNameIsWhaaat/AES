1.Разбиение фразы на блоки

    "Мы из поколения" - 15 символов (15 байт в ASCII кодировке).
    " мужчин, выращен" - 16 символов (16 байт).
    "ных женщинами. Помо" - 16 символов (16 байт).
    "жет ли другая женщи" - 16 символов (16 байт).
    "на в решении наших " - 16 символов (16 байт).
    "проблем?" - 9 символов (9 байт).
    Таким образом, первый блок содержит 15 байтов, а не 16, как остальные блоки. Первый блок нужно дополнить, чтобы его размер стал 16 байтам для соответствия требованиям AES.

2.Преобразование кадого символа в бинарный формат

    "Мы из поколения" - в ASCII это будет:

    М - 77
    ы - 109
    - 32
    и - 105
    з - 122
    - 32
    п - 108
    о - 111
    к - 107
    о - 111
    л - 108
    е - 101
    н - 110
    и - 105
    я - 121

    01001101 01111001 00100000 01101001 01111010 00100000 01110000 01101111 01101011 01101111 01101100 01100101 01101110 01101001 01111001 01100001

3.Первый блок данных будет выглядеть следующим образом (только с бинарными числами)

    77 109 32 105
    122 32 108 111
    107 111 108 101
    110 105 121 0

4.Инициализация рандомно IV(вектор инициализации). Имеет следующий вид

    43 67 23 94
    56 21 67 34
    76 99 12 54
    23 45 78 89

5.XOR IV и первого закодированного блока. Для каждого последующего блока данных мы берем его и выполняем операцию XOR с предыдущим зашифрованным блоком.

    Первый блок данных: 
    77  109 32  105
    122 32  108 111
    107 111 108 101
    110 105 121 0

    IV: 
    43 67 23 94
    56 21 67 34
    76 99 12 54
    23 45 78 89

    Результат XOR с IV: 
    34  42  11  199
    90  13  75  121
    35  42  100 95
    117 108  199 89

6. Передача блока для последующего шифрования методом AES. В AES-128 каждый блок данных будет проходить через 10 раундов шифрования. Каждый раунд включает в себя последовательное применение четырех основных операций шифрования: SubBytes, ShiftRows, MixColumns и AddRoundKey.
    
    1. AddRoundKey: В этом шаге каждый байт блока данных XOR'ится с соответствующим байтом из раундового ключа. Раундовые ключи получаются из основного ключа шифрования и проходят через процесс ключевого расширения. Это добавляет дополнительный уровень защиты к блоку данных. 
        Пример ключа: key = b'\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x97\x32\x67\x45\xab\x8c'
        
        В AES ключевой график расширяется путем последовательного генерирования раундовых ключей из исходного ключа. Для ключа AES-128 генерируется 10 раундовых ключей (для каждого раунда шифрования и один дополнительный ключ для последнего раунда).

        Процесс расширения ключа состоит из следующих этапов:

        Начальный раундовый ключ: Начальный раундовый ключ совпадает с исходным ключом.

        Генерация новых ключей: Затем последовательно генерируются новые раундовые ключи для каждого раунда шифрования. Каждый новый ключ генерируется на основе предыдущего ключа с помощью функции подключа, которая включает в себя такие операции, как циклический сдвиг байт, замена байтов с помощью S-блока и XOR с раундовыми константами.

        Раундовые константы: Во время генерации новых ключей используются раундовые константы, которые представляют собой предопределенные значения, зависящие от номера раунда. Они вносят важный вклад в стойкость шифра.

        Процесс расширения ключа применяется для создания набора ключей, которые затем используются на разных этапах шифрования для каждого раунда. Каждый раундовый ключ содержит ключи для каждого байта состояния, которые используются в процессе AddRoundKey на каждом раунде шифрования.

    2. SubBytes: В этом шаге каждый байт блока данных заменяется на значение из S-блока (подстановочной таблицы), которая является частью стандартного шифра AES. Это обеспечивает нелинейность в шифре и увеличивает его стойкость к криптоанализу.
        Рассмотрим один байт 0x53(0x обозначает префикс для указания того, что число записано в шестнадцатеричной системе счисления) из блока. Найдем координаты этого байта в S-блоке. В AES S-блок является двумерной таблицей размером 16x16, поэтому первый байт будет иметь координаты (5, 3).Теперь мы находим значение в S-блоке по этим координатам. Для байта 0x53 значение в S-блоке будет 0xED. Если у нас есть значение с буквами, например 0xAB, чтобы найти координаты в S-блоке, мы заменяем A на 10 и B на 11, и получаем координаты (10, 11).

    3. ShiftRows: В этом шаге каждая строка блока данных сдвигается циклически на различное количество позиций. В шифре AES применяется следующий принцип сдвига строк в операции ShiftRows:
        Первая строка блока данных остается неизменной (не сдвигается).
        Вторая строка сдвигается на одну позицию влево.
        Третья строка сдвигается на две позиции влево.
        Четвертая строка сдвигается на три позиции влево.

    4. MixColumns: В этом шаге каждый столбец блока данных перемешивается. Для примера применим операцию перемешивания столбцов:
        Процесс MixColumns состоит в умножении каждого столбца на фиксированный многочлен в поле Галуа и последующем сложении результатов по модулю над определенным многочленом в этом поле.

        Пусть $c(x) = [c_0, c_1, c_2, c_3]^T$ - столбец состояния (State).
        Каждый элемент $c_i$ столбца рассматривается как элемент поля Галуа GF($2^8$).
        Умножается на многочлен $a(x) = [03, 01, 01, 02]^T$ в поле Галуа.
        То есть, для каждого столбца выполняется следующее преобразование:

        $c(x) = [c_0, c_1, c_2, c_3]^T$

        $c(x) = [02c_0 + 03c_1 + 01c_2 + 01c_3, 01c_0 + 02c_1 + 03c_2 + 01c_3, 01c_0 + 01c_1 + 02c_2 + 03c_3, 03c_0 + 01c_1 + 01c_2 + 02c_3]^T$

        где операции умножения и сложения производятся в поле Галуа.

    5. AddRoundKey (последний раунд): В последнем раунде шифрования дополнительно к операции XOR с раундовым ключом также выполняется операция XOR с раундовым ключом, полученным из последнего ключевого расширения. звучит странно

7. После того, как все блоки данных были зашифрованы, процесс шифрования завершается. В результате получается зашифрованный текст, который можно использовать для передачи или хранения в зашифрованном виде.

*PBKDF2 (Password-Based Key Derivation Function 2) - это функция производства ключа, которая используется для преобразования паролей или секретных ключей в длинные ключи с использованием итеративного процесса хеширования. Она является одним из стандартов для производства ключей из паролей и широко применяется в криптографии и информационной безопасности.

    Процесс работы PBKDF2 можно описать следующим образом:

    Пользователь предоставляет пароль и соль.
    PBKDF2 объединяет пароль и соль и применяет хеш-функцию к этой комбинации.
    Полученный хеш затем используется как вход для нового хеширования, и этот процесс повторяется многократно (заданное количество итераций).
    В конце процесса вычисляется ключ заданной длины.

Расшифровка данных
    Расшифровка блоков шифртекста с использованием ключа (InvCipher): Первый этап декодирования в AES - это расшифровка зашифрованных данных с использованием ключа. В AES операция расшифровки выполняется обратным порядком к операции шифрования. В этом этапе к каждому блоку шифртекста применяется ключевой граф с обратными операциями. Для AES-128 это состоит из 10 раундов, каждый из которых состоит из операций InvSubBytes, InvShiftRows, InvMixColumns и AddRoundKey.
        AddRoundKey (Обратное сложение ключа раунда):

        В этом этапе каждый байт шифртекста комбинируется с соответствующим байтом ключа раунда с использованием операции XOR.
        Каждый байт ключа раунда является результатом расширения ключа и преобразования подключа раунда.
        Это обратная операция к операции AddRoundKey, выполненной во время шифрования.
        InvShiftRows (Обратное смещение строк):

        В этой операции каждая строка матрицы состояния сдвигается вправо на различные смещения.
        Вторая строка сдвигается на 1 байт, третья строка сдвигается на 2 байта, четвёртая строка сдвигается на 3 байта.
        Это обратная операция к операции ShiftRows, выполненной во время шифрования.
        InvSubBytes (Обратное подстановочное преобразование):

        В этом этапе каждый байт матрицы состояния заменяется на соответствующее значение из обратной S-блока (S-box).
        Обратный S-блок используется для обратного преобразования подстановки.
        Это обратная операция к операции SubBytes, выполненной во время шифрования.
        InvMixColumns (Обратное перемешивание столбцов):

        В этой операции каждый столбец матрицы состояния умножается на матрицу обратного преобразования MixColumns.
        Обратное преобразование MixColumns применяется к каждому столбцу отдельно.
        Это обратная операция к операции MixColumns, выполненной во время шифрования.
        Декодирование последнего раунда (Round):

        В последнем раунде декодирования не выполняется операция MixColumns, поэтому последний раунд состоит только из операций AddRoundKey, InvShiftRows и InvSubBytes.
        После завершения последнего раунда получается исходный текст.

    Удаление дополнения (Padding removal): Если данные были дополнены до размера блока перед шифрованием (например, с использованием схемы дополнения PKCS7), то после декодирования их следует удалить. Это делается для восстановления оригинальной длины данных.

    Преобразование байтов в исходный текст: После декодирования блоков шифртекста и удаления дополнения полученные байты обычно преобразуются обратно в исходный текст с использованием правильной кодировки (например, UTF-8).